<?php
// $Id$
/**
 * @file
 * CVS backend for Version Control API - Provides CVS commit information and
 * account management as a pluggable backend.
 *
 * Copyright 2006 by Karthik ("Zen", http://drupal.org/user/21209)
 * Copyright 2006, 2007 by Derek Wright ("dww", http://drupal.org/user/46549)
 * Copyright 2007 by Jakob Petsovits ("jpetso", http://drupal.org/user/56020)
 */

/**
 * Implementation of hook_install().
 */
function versioncontrol_cvs_install() {
  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      db_query("CREATE TABLE {versioncontrol_cvs_accounts} (
        uid int unsigned NOT NULL default 0,
        repo_id int unsigned NOT NULL default 0,
        password varchar(64) NOT NULL default '',
        PRIMARY KEY (uid, repo_id)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      db_query("CREATE TABLE {versioncontrol_cvs_repositories} (
        repo_id int unsigned NOT NULL default 0,
        modules varchar(255) NOT NULL default '',
        update_method tinyint unsigned NOT NULL default 0,
        updated int unsigned NOT NULL default 0,
        run_as_user varchar(255) NOT NULL default '',
        PRIMARY KEY (repo_id)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");

      db_query("CREATE TABLE {versioncontrol_cvs_commits} (
        vc_op_id int unsigned NOT NULL default 0,
        branch_id int unsigned NOT NULL default 0,
        PRIMARY KEY (vc_op_id)
      ) /*!40100 DEFAULT CHARACTER SET utf8 */");
      break;

    case 'pgsql':
      db_query("CREATE TABLE {versioncontrol_cvs_accounts} (
        uid int NOT NULL default 0,
        repo_id int NOT NULL default 0,
        password varchar(64) NOT NULL default '',
        PRIMARY KEY (uid, repo_id)
      )");

      db_query("CREATE TABLE {versioncontrol_cvs_repositories} (
        repo_id int NOT NULL default 0,
        modules varchar(255) NOT NULL default '',
        update_method smallint NOT NULL default 0,
        updated int NOT NULL default 0,
        run_as_user varchar(255) NOT NULL default '',
        PRIMARY KEY (repo_id)
      )");

      db_query("CREATE TABLE {versioncontrol_cvs_commits} (
        vc_op_id int NOT NULL default 0,
        branch_id int NOT NULL default 0,
        PRIMARY KEY (vc_op_id)
      )");
      break;
  }
}


/**
 * Implementation of hook_uninstall().
 */
function versioncontrol_cvs_uninstall() {
  // Make sure we can access the required functions even from the .install file.
  include_once(drupal_get_path('module', 'versioncontrol') .'/versioncontrol.module');
  include_once(drupal_get_path('module', 'versioncontrol_cvs') .'/versioncontrol_cvs.module');

  if (db_table_exists('versioncontrol_repositories')) {
    $result = db_query("SELECT repo_id FROM {versioncontrol_repositories}
                        WHERE vcs = 'cvs'");
    while ($repository = db_fetch_array($result)) {
      versioncontrol_delete_repository($repository);
    }
  }

  db_query('DROP TABLE {versioncontrol_cvs_accounts}');
  db_query('DROP TABLE {versioncontrol_cvs_repositories}');
  db_query('DROP TABLE {versioncontrol_cvs_commits}');
  db_query('DROP TABLE {versioncontrol_cvs_item_revisions}');
}


// Update functions.

/**
 * Update 1: Remove the source_revision column from the files table,
 *   because we can retrieve it programmatically.
 */
function versioncontrol_cvs_update_1() {
  $ret = array();

  $result = db_query('SELECT item_revision_id, source_revision
                      FROM {versioncontrol_cvs_item_revisions}
                      WHERE action = 5'); // 5 == VERSIONCONTROL_ACTION_DELETED
                      // (that was then, VERSIONCONTROL_ACTION_DELETED is now 6)

  while ($item_revision = db_fetch_object($result)) {
    // Calculate the revision number that follows the source revision,
    // as that is the current (dead) one and that is being stored now.
    $source_revision = $item_revision->source_revision;
    $parts = explode('.', $source_revision);
    $last_part = array_pop($parts);
    $last_part = ((int) $last_part) + 1;
    $parts[] = (string) $last_part;
    $revision = implode('.', $parts);

    // Ok, that's it, now store it back (but in the 'revision' field).
    // "type = 2" is for VERSIONCONTROL_ITEM_FILE_DELETED (or was: it's now 3).
    $ret[] = update_sql("UPDATE {versioncontrol_cvs_item_revisions}
                         SET revision = '$revision', type = 2
                         WHERE item_revision_id = ". $item_revision->item_revision_id);
  }

  // Now the easy part: deleting the source_revision column
  $ret[] = update_sql('ALTER TABLE {versioncontrol_cvs_item_revisions}
                       DROP COLUMN source_revision');
  return $ret;
}

/**
 * Update 2: Rename and reassign primary key values, hand in hand with
 *   the same change in the API module.
 *   This function may only be called from within versioncontrol_update_2()
 *   as it relies on an intermediary schema state, so there's some magic
 *   that lets the update fail if not called from within the other update.
 */
function versioncontrol_cvs_update_2() {
  $ret = array();
  $args = func_get_args();

  if ($args[0] !== 'do the upgrade') {
    $ret[] = array(
      'success' => TRUE,
      'query' => 'The CVS backend update has (hopefully) been executed from within the Version Control API update 2. (Look above for {versioncontrol_cvs_*} tables.) If anything went wrong, you\'ll probably have to figure it out by yourself.',
    );
    return $ret;
  }

  // Step 1) Rename commit_id -> vc_op_id, and create new columns for the
  //         branch and tag operation extension tables. We'll keep commit ids,
  //         whereas tag op and branch op ids will be made up anew.
  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_commits} CHANGE COLUMN commit_id vc_op_id int unsigned NOT NULL default 0");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_revisions} CHANGE COLUMN commit_id vc_op_id int unsigned NOT NULL default 0");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_branch_points} ADD vc_op_id int unsigned NOT NULL default 0");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_tags} ADD vc_op_id int unsigned NOT NULL default 0");
      break;

    case 'pgsql':
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_commits} RENAME commit_id TO vc_op_id");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_revisions} RENAME commit_id TO vc_op_id");
      db_add_column($ret, 'versioncontrol_cvs_item_branch_points', 'vc_op_id', 'int', array('not null' => TRUE, 'default' => 0));
      db_add_column($ret, 'versioncontrol_cvs_item_tags', 'vc_op_id', 'int', array('not null' => TRUE, 'default' => 0));
      break;
  }

  // Step 2) Determine and store the vc_op_id values of branch and tag
  //         operations. This is the part that requires this function
  //         to be called in the middle of versioncontrol_update_2(), because
  //         it's the only point in time where both the original id and
  //         vc_op_id exist in the API module's tables.
  $count = 0;
  $result = db_query("SELECT * FROM {versioncontrol_branch_operations}");
  while ($tag_op = db_fetch_object($result)) {
    ++$count;
    db_query("UPDATE {versioncontrol_cvs_item_branch_points}
              SET vc_op_id = %d WHERE branch_op_id = %d",
              $tag_op->vc_op_id, $tag_op->branch_op_id);
  }
  $result = db_query("SELECT * FROM {versioncontrol_tag_operations}");
  while ($tag_op = db_fetch_object($result)) {
    ++$count;
    db_query("UPDATE {versioncontrol_cvs_item_tags}
              SET vc_op_id = %d WHERE tag_op_id = %d",
              $tag_op->vc_op_id, $tag_op->tag_op_id);
  }
  if ($count > 0) {
    $ret[] = array(
      'success' => TRUE,
      'query' => $count .' UPDATE statements for {versioncontrol_cvs_item_branch_points} and {versioncontrol_item_tags}, adopting vc_op_id from the appropriate values in {versioncontrol_operations}.',
    );
  }

  // Now that the ids have been migrated, reassign the primary key
  // and delete the obsolete columns.
  switch ($GLOBALS['db_type']) {
    case 'mysqli':
    case 'mysql':
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_branch_points} DROP PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_branch_points} ADD PRIMARY KEY (vc_op_id, item_revision_id)");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_tags} DROP PRIMARY KEY");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_tags} ADD PRIMARY KEY (vc_op_id, item_revision_id)");
      break;

    case 'pgsql':
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_branch_points} DROP CONSTRAINT {versioncontrol_cvs_item_branch_points}_pkey"); // Drop the primary key constraint which would prohibit us from deleting the primary key column.
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_branch_points} ADD PRIMARY KEY (vc_op_id, item_revision_id)");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_tags} DROP CONSTRAINT {versioncontrol_cvs_item_tags}_pkey");
      $ret[] = update_sql("ALTER TABLE {versioncontrol_cvs_item_tags} ADD PRIMARY KEY (vc_op_id, item_revision_id)");
      break;
  }
  $ret[] = update_sql('ALTER TABLE {versioncontrol_cvs_item_branch_points} DROP COLUMN branch_op_id');
  $ret[] = update_sql('ALTER TABLE {versioncontrol_cvs_item_tags} DROP COLUMN tag_op_id');

  return $ret;
}

/**
 * Update 3: Move item revisions to the API module's tables.
 */
function versioncontrol_cvs_update_3() {
  $ret = array();

  // Make sure we can access the required functions even from the .install file.
  include_once(drupal_get_path('module', 'versioncontrol') .'/versioncontrol.module');
  include_once(drupal_get_path('module', 'versioncontrol_cvs') .'/versioncontrol_cvs.module');

  // Step 0: Version Control API now provides sane constants for item and
  //   action types - starting at 1 instead of 0. So before moving those to
  //   the centralized tables, make sure they contain the correct constants.
  $ret[] = update_sql('UPDATE {versioncontrol_cvs_item_revisions}
                       SET action = action + 1, type = type + 1');

  // Step 1: item revisions (or just "items" in short).
  $items_by_old_id = array();
  $items_structured = array();
  $result = db_query('SELECT ir.item_revision_id, ir.vc_op_id, ir.action,
                             ir.type, ir.path, ir.revision, op.repo_id
                      FROM {versioncontrol_cvs_item_revisions} ir
                        INNER JOIN {versioncontrol_operations} op
                          ON ir.vc_op_id = op.vc_op_id');

  // Firstly, we register all the revisions with Version Control API.
  while ($item = db_fetch_array($result)) {
    $old_item_revision_id = $item['item_revision_id'];
    $item['item_revision_id'] = db_next_id('{versioncontrol_item_revisions}_item_revision_id');

    $items_structured[$item['repo_id']][$item['path']][$item['revision']] = $item;
    $items_by_old_id[$old_item_revision_id] = $item;

    $ret[] = update_sql(
      "UPDATE {versioncontrol_cvs_item_revisions}
        SET item_revision_id = ". $item['item_revision_id'] ."
        WHERE item_revision_id = ". $old_item_revision_id);

    $ret[] = update_sql(
      "INSERT INTO {versioncontrol_item_revisions}
        (item_revision_id, repo_id, path, revision, type)
        VALUES (". $item['item_revision_id'] .", ". $item['repo_id'] .",
                '". $item['path'] ."', '". $item['revision'] ."',
                ". $item['type'] .")");

    $ret[] = update_sql(
      "INSERT INTO {versioncontrol_operation_items}
        (vc_op_id, item_revision_id, type)
        VALUES (". $item['vc_op_id'] .", ". $item['item_revision_id'] .",
                ". VERSIONCONTROL_OPERATION_MEMBER_ITEM .")");
  }

  // When everything is in there, we can connect the dots (a.k.a. source items)
  // assuming that we recorded the previous item revisions at all.
  foreach ($items_structured as $repo_id => $repo_items) {
    foreach ($repo_items as $path => $path_items) {
      foreach ($path_items as $revision => $item) {
        if ($item['action'] == VERSIONCONTROL_ACTION_ADDED) {
          $source_item_revision_id = 0; // the special "empty" item
        }
        else {
          $previous_revision = versioncontrol_cvs_get_previous_revision_number($revision);

          if (isset($path_items[$previous_revision])) {
            $source_item = $path_items[$previous_revision];
            $source_item_revision_id = $source_item['item_revision_id'];
          }
        }

        if (isset($source_item_revision_id)) {
          $ret[] = update_sql(
            "INSERT INTO {versioncontrol_source_items}
              (item_revision_id, source_item_revision_id, action)
              VALUES (". $item['item_revision_id'] .",
                      ". $source_item_revision_id .",
                      ". $item['action'] .")");
        }
      }
    }
  }

  // Step 2: tags and branches - same code, so do both at once.
  $tables = array('versioncontrol_cvs_item_tags', 'versioncontrol_cvs_item_branch_points');

  foreach ($tables as $table) {
    $result = db_query('SELECT item_revision_id, vc_op_id FROM {'. $table .'}');

    while ($op_mapping = db_fetch_object($result)) {
      if (!isset($items_by_old_id[$op_mapping->item_revision_id])) {
        continue;
      }
      $item = $items_by_old_id[$op_mapping->item_revision_id];

      $ret[] = update_sql(
        "INSERT INTO {versioncontrol_operation_items}
          (vc_op_id, item_revision_id, type)
          VALUES (". $op_mapping->vc_op_id .", ". $item['item_revision_id'] .",
                  ". VERSIONCONTROL_OPERATION_MEMBER_ITEM .")");
    }
  }

  // Step 3: Remove obsolete tables and columns.
  foreach ($tables as $table) {
    $ret[] = update_sql('DROP TABLE {'. $table .'}');
  }
  $ret[] = update_sql(
    'ALTER TABLE {versioncontrol_cvs_item_revisions}
      DROP COLUMN vc_op_id, DROP COLUMN action, DROP COLUMN type,
      DROP COLUMN path, DROP COLUMN revision');
      // KEEP lines_added, lines_removed, and of course item_revision_id

  return $ret;
}

/**
 * Update 4: Move remaining item revision info to the API module's tables, that
 *   is, the lines-changed information in {versioncontrol_cvs_item_revisions}.
 */
function versioncontrol_cvs_update_4() {
  $ret = array();

  $result = db_query('SELECT cir.item_revision_id, cir.lines_added,
                             cir.lines_removed
                      FROM {versioncontrol_cvs_item_revisions} cir
                        INNER JOIN {versioncontrol_item_revisions} ir
                          ON cir.item_revision_id = ir.item_revision_id
                        INNER JOIN {versioncontrol_source_items} si
                          ON ir.item_revision_id = si.item_revision_id
                      WHERE ir.type = '. VERSIONCONTROL_ITEM_FILE .'
                        AND si.action = '. VERSIONCONTROL_ACTION_MODIFIED);
  while ($item = db_fetch_object($result)) {
    $ret[] = update_sql('UPDATE {versioncontrol_source_items}
                          SET line_changes_recorded = 1,
                              line_changes_added = '. $item->lines_added .',
                              line_changes_removed = '. $item->lines_removed .'
                          WHERE item_revision_id = '. $item->item_revision_id);
  }
  $ret[] = update_sql('DROP TABLE {versioncontrol_cvs_item_revisions}');

  return $ret;
}
